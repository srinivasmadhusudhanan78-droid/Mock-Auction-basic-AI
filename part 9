import random
from typing import Optional

# -------------------------------
# AI Bidding Logic with Single ±0.5 Cr Adjustment
# -------------------------------
_ai_bid_adjustment_done = {}  # keeps track of which AI teams applied ±0.5Cr for each player

def ai_bid(team, player, current_bid: float, rng: random.Random) -> Optional[float]:
    """
    AI bidding:
    - Each AI team can bid ±0.5 Cr around hidden reserve only once per player
    - Must respect hidden reserve ceiling
    - Cannot exceed 1%-30% of team purse
    """
    global _ai_bid_adjustment_done

    if not team.has_slot() or not team.can_afford(player.base_price):
        return None

    reserve = player._hidden_reserve or player.base_price
    tier_hi = player._tier_hi or (reserve + 1.0)

    # Track if this AI team has already applied ±0.5Cr for this player
    key = f"{team.name}_{player.name}"
    if key not in _ai_bid_adjustment_done:
        adjustment = rng.choice([-0.5, 0, 0.5])
        _ai_bid_adjustment_done[key] = True
    else:
        adjustment = 0.0  # no more ±0.5Cr adjustment for this team

    bid = reserve + adjustment
    bid = min(bid, tier_hi)  # respect tier ceiling

    # Cap bid to 1%-30% of team purse
    max_allowed = team.purse * 0.3
    min_allowed = team.purse * 0.01
    bid = min(bid, max_allowed)
    bid = max(bid, min_allowed)

    # Must be higher than current bid to place
    if current_bid is not None and bid <= current_bid:
        return None

    # Ensure team can afford
    if bid > team.purse:
        return None

    return round(bid, 2)








UPDATED
# -------------------------------
# Part 9 - AI Bidding Behavior (Updated with Increment Rule)
# -------------------------------
import random
from typing import Optional

def ai_bid(team, player, current_bid: float, rng: random.Random,
           increment_used: bool, teams: list) -> Optional[float]:
    """
    Determine AI bid for a player:
    - Must respect hidden reserve ceiling
    - Can bid ±0.5Cr around hidden reserve
    - Cannot exceed 1%-30% of team purse
    - Special rule: If user bids exactly the tier ceiling,
      only one AI team (highest purse with open slot for role) 
      may place +0.5Cr increment ONCE per player.
    """
    if not team.has_slot() or not team.can_afford(player.base_price):
        return None

    reserve = player._hidden_reserve or player.base_price
    tier_hi = player._tier_hi or (reserve + 1.0)

    # --- Special Increment Rule ---
    # If current bid is exactly tier ceiling, only one AI can bid +0.5
    if current_bid == tier_hi and not increment_used:
        # Find eligible AI team (highest purse with role slot open)
        eligible_teams = [t for t in teams if t.has_slot_for(player.role) and t.purse >= current_bid + 0.5]
        if not eligible_teams:
            return None
        richest_team = max(eligible_teams, key=lambda t: t.purse)
        if team == richest_team:
            bid = current_bid + 0.5
            # Respect purse constraints (1%–30%)
            if bid > team.purse * 0.3 or bid < team.purse * 0.01:
                return None
            return round(bid, 2)
        else:
            return None

    # --- Normal AI bidding ---
    # AI random bid within ±0.5Cr of hidden reserve
    bid = reserve + rng.choice([-0.5, 0, 0.5])
    bid = min(bid, tier_hi)  # cap at ceiling

    # Cap bid based on team purse (1%-30%)
    max_allowed = team.purse * 0.3
    min_allowed = team.purse * 0.01
    bid = min(bid, max_allowed)
    bid = max(bid, min_allowed)

    # Must be higher than current bid
    if current_bid is not None and bid <= current_bid:
        return None

    if bid > team.purse:
        return None

    return round(bid, 2)