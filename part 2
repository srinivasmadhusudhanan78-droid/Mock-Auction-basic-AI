# -------------------------------
# CLI Helpers
# -------------------------------
def prompt_human_bid(player: Player, current_bid: Optional[Bid]) -> Optional[float]:
    print(f"\nYour turn for {player.name} ({player.role}, base {player.base_price}Cr, age {player.age}).")
    if current_bid is None:
        print("No bids yet. Enter amount >= base or 'p' to pass.")
    else:
        print(f"Current bid: {current_bid.team} at {current_bid.amount}Cr.")
    s = input("Bid: ").strip().lower()
    if s in ("p", "pass", ""):
        return None
    try:
        return round(float(s), 2)
    except:
        return None

def attach_cli(engine: "AuctionEngine"):
    def on_turn(player: Player, current_bid: Optional[Bid]) -> Optional[float]:
        return prompt_human_bid(player, current_bid)
    engine.on_human_turn = on_turn

# -------------------------------
# Default Teams / AuctionState
# -------------------------------
def default_teams(human_team: str) -> AuctionState:
    teams = {
        "csk": Team("csk", 16, 7, 55.0, 1),
        "mi":  Team("mi", 16, 8, 45.0, 1),
        "dc":  Team("dc", 17, 7, 73.0, 2),
        "pbks":Team("pbks", 20, 8, 110.5, 4),
        "gt":  Team("gt", 16, 7, 69.0, 1),
        "rr":  Team("rr", 15, 7, 41.0, 0),
        "kkr": Team("kkr", 15, 6, 51.0, 0),
        "rcb": Team("rcb", 18, 8, 83.0, 3),
        "lsg": Team("lsg", 16, 7, 69.0, 1),
        "srh": Team("srh", 16, 5, 45.0, 1),
    }
    return AuctionState(teams=teams, constraints=Constraints(), human_team=human_team)

# -------------------------------
# Main CLI Loop
# -------------------------------
def main():
    print("Select your team: csk, mi, kkr, rcb, gt, lsg, rr, pbks, dc, srh")
    human = input("Team: ").strip().lower()
    state = default_teams(human)
    engine = AuctionEngine(state, seed=42)
    attach_cli(engine)

    while True:
        name = input("\nEnter player name (or 'q' to quit): ").strip()
        if name.lower() in ("q", "quit", "exit"):
            break
        slot = input("Slot: ").strip()
        base = float(input("Base price (Cr): ").strip())
        prev = input("Previous team for RTM (or '-' if none): ").strip().lower()
        prev_team = None if prev == "-" else prev
        age = None
        role = None

        player = Player(name=name, slot=slot, base_price=base, previous_team=prev_team, age=age, role=role)
        result = engine.process_player(player)

        if result.sold_to:
            print(f"SOLD: {player.name} -> {result.sold_to} for {result.price}Cr ({result.reason})")
        else:
            print(f"UNSOLD: {player.name}")

if __name__ == "__main__":
    main()

# -------------------------------
# AuctionEngine with Multi-bid
# -------------------------------
class AuctionEngine:
    def __init__(self, state: AuctionState, seed: Optional[int] = None):
        self.state = state
        self.rng = random.Random(seed)

    def process_player(self, player: Player, is_overseas: bool = False) -> SaleResult:
        player = enrich_player(player)
        player = assign_tier_and_reserve(player, self.rng)

        order = list(self.state.teams.keys())
        self.rng.shuffle(order)
        current_bid: Optional[Bid] = None
        last_bidder = None

        print(f"\nAuction: {player.name} ({'O' if is_overseas else ''}) Base {player.base_price}Cr")

        while True:
            all_pass = True
            for tname in order:
                team = self.state.teams[tname]
                if not team.has_slot() or not team.can_afford(player.base_price):
                    continue

                if tname == self.state.human_team:
                    decision = self.on_human_turn(player, current_bid)
                    bid_amount = decision
                else:
                    bid_amount = ai_should_bid(
                        team, player, current_bid,
                        first_bidder=(current_bid is None),
                        rng=self.rng
                    )

                if bid_amount is None:
                    continue
                if current_bid and bid_amount <= current_bid.amount:
                    continue
                if not team.can_afford(bid_amount):
                    continue

                current_bid = Bid(team=tname, amount=bid_amount)
                last_bidder = tname
                all_pass = False

                # ✅ Minimal message
                print(f"{tname}: {fmt_cr(bid_amount)}")

            if all_pass:
                break

        if current_bid is None:
            result = SaleResult(player, None, None, player.role or Role.B, False, "unsold")
            self._record_sale(result)
            print("UNSOLD")
            return result

        # RTM check
        winner_team = current_bid.team
        price = current_bid.amount
        rtm_used = False
        if player.previous_team and player.previous_team in self.state.teams:
            prev_team = self.state.teams[player.previous_team]
            if prev_team.rtm_available > 0 and prev_team.can_afford(price) and prev_team.has_slot():
                if self.on_rtm_decision(prev_team.name, player, price):
                    winner_team = prev_team.name
                    rtm_used = True
                    prev_team.rtm_available -= 1

        win_team_obj = self.state.teams[winner_team]
        win_team_obj.add_player(player, price, is_overseas=is_overseas)

        result = SaleResult(player, winner_team, price, player.role or Role.B, rtm_used, "highest_bid")
        self._record_sale(result)

        # ✅ Minimal result
        print(f"SOLD: {player.name} -> {winner_team} {fmt_cr(price)}{' RTM' if rtm_used else ''}")
        return result